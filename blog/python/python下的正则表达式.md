## 概述

正则表达式是一种文本模式，也可以看作一个微小的编程语言。他使用单个字符串来描述、匹配一些列匹配某个句法规则的字符串。在python中re模块提供了正则表达式的匹配操作。

## 正则表达式语法

### 匹配字符

大多数字符本身只会匹配他们自己，例如正则表达式test将完全匹配字符串test（可以开启忽略大小写模式来匹配Test TEST这样的字符串）。但是这条规则的例外就是正则表达式中规定了一些特殊的字符，并且他们不匹配自己而是表示应该匹配的一些与中不同的东西，通过使用他们来影响正则表达式的其他部分。正则表达式的编写很大程度上就是灵活利用这些匹配字符。  
匹配字符的完整列表：

> . ^ $ * + ? {} [] \ | ()  

对于正则表达式的学习基本上就是对这些匹配字符的学习。

#### 字符类 [] .

中括号用于指定字符类，它是你希望匹配的一组字符。可以单独列出字符，也可以通过给出两个字符并使用-标记将它们分开来表示一系列字符。在字符类里元字符不生效。可以通过包含一个^作为该字符类的第一个字符表示补集，如果插入在其他位置则没有其他含义。点号是一个特殊的匹配字符，它可以匹配除了换行符以外的任何内容。在python中有一个可选模式(re.DOTALL)甚至可以匹配包括换行符在内的任何内容。  
实例：

```
[xyz]   # 匹配x或y或z
[a-z]   # 匹配从a到z中的任意字母
[A-Z]   # 匹配从A到Z中的任意字母
[0-9]   # 匹配从0到9中的任意数字
[^xyz]  # 匹配除了x y z以外的其他任意字符
[^a-n]  # 匹配除了a到n外的其他任意字符
[xyz$]  # 匹配x或y或z或$字符
[x^]    # 匹配x或^字符
[a-z0-9A-Z] #匹配所有字母或数字字符
.       # 匹配除了换行符外的任何字符
[()\[\]{}]  #匹配括号，注意中括号需要使用\转义
```

#### 重复 + * ? {}

我们在实际使用中，常常需要匹配同一个类型的字符多次，比如匹配11位的电话号码，我们不可能将[0-9]写11遍(当然这样也可以实现匹配，但是效率太差了)，此时就需要使用到重复元字符来实现重复匹配。

星号*
:   含义：对他前面的正则式匹配0次或任意次数，(在python中为贪婪匹配即尽量多的匹配字符串)
:   示例：ab* 会匹配'a' 'ab' 'abbb'等，(对于贪婪匹配例如字符串’abbbac'会匹配'abbb')

加号+
:   含义：对他前面的正则式匹配1次或任意次数(在python中为贪婪匹配)
:   示例：ab+ 会匹配‘ab' 'abb' 等a后跟随1个或1个以上的b的字符串

问号?
:   含义：对他前面的正则式匹配0次或1次。(在python中为贪婪匹配)
:   示例：ab?会匹配 'a' 'ab'

非贪婪匹配 *? +? ??
:   含义：上面所讲的重复元字符在python中都是贪婪匹配的即他们会尽可能多的匹配字符串，有时候我们并不需要这种行为可以在修饰符后添加?来达到非贪婪匹配的结果
:   示例：例如对于字符串'\<a> b \<c>' 如果正则式为 \<.\*> 将匹配真个字符串，但是如果为 \<.*?> 将仅匹配\<a>

{m}
:   含义：对其前面的正则式匹配m个重复，少于m都会导致匹配的失败
:   示例：a{6} 将匹配6个a

{m,n}
:   含义：对正则式进行m到n次匹配，在python中为贪婪匹配。如果忽略m表示下界为0,如果忽略n表示上界为无限次
:   示例：a{4,}b 匹配 'aaaab' 或a跟任意个a最后尾随个b
:   引申：实际上*可以用{0,}表示，+可以用{1,}表示，？可以用{0,1}表示

{m,n}?
:   含义：与上面相同，不过这里是非贪婪匹配
:   示例：对于’aaaaaa' {3,5}匹配‘aaaaa’ {3,5}?匹配'aaa'

#### 其他特殊字符 ^ $ |

^
:   含义：匹配字符串的开头
:   示例：例如对于字符串‘a1abcdef' 正则式\^[0-9]abc返回None

$
:   含义：匹配字符串的结尾，实际上^ \$就是一个位置标记，表示要匹配的是一个字符串的开始和结尾。例如用在用户输入表单的时候通过^正则式$来匹配完整的一段输入而不是匹配其中的某一段。
:   引申：默认情况下^ \$匹配整个字符串(例如一篇文章，无论中间多少行，都匹配文章的开头结尾)，我们可以开启re.MULTILINE模式，开启后^匹配字符串开始，和每一行的开始(\n或\r后开始匹配)，$也匹配整个字符串结尾以及每一行的结尾(匹配到\n或\r前)

A|B
:   含义：A和B可以是任意正则式来创建一个新的正则式表示匹配A或者B。任意个正则式都可以使用|连接。扫描目标字符串的时候，|分割的正则式从左向右进行匹配，当一个样式完全匹配的时候这个分支被接受，而不再进行下一个分配。也可以认为|绝不贪婪。
:   示例：s|pool是匹配或pool,如果写成(s|p)ool表示匹配sool或pool

#### 转义字符 \

|转义字符|含义|
|---|---|
|\w|匹配字母数字,等同于[a-zA-Z0-9]|
|\W|匹配非字母数字,等同于[^a-zA-Z0-9]|
|\s|匹配任意空白字符，等同于[\t\n\r\f]|
|\S|匹配任意非空字符，等同于[^\t\n\r\f]|
|\d|匹配任意数字，等同于[0-9]|
|\D|匹配任意非数字|
|\b|匹配一个单词边界，也就是指单词和空格间的位置，例如'er\b'可以匹配"never thing"中的'er'但是不能匹配"verb"中的'er'|
|\B|匹配非单词边界，er\B能匹配 "verb" 中的 'er'，但不能匹配 "never thing" 中的 'er'|
|\un|匹配一个Unicode转义序列，其中n是一个用四个十六进制数字表示的Unicode字符 \u00A9版权符号|

#### 运算符优先级

1. \    #转义字符
2. (),(?:),(?=),[]  #圆括号方括号
3. \* + ? {} #限定符
4. ^ \$ #定位点
5. |    #或操作


## python的re模块

### 常量

1. re.ASCII(re.A) 让\w \W \b \B \d \D \s \S只匹配ASCII，而不是Unicode。内联标志为(?a)
2. re.IGNORECASE(re.I) 进行忽略大小写匹配表达式即[A-Z]也会匹配小写字符，内联标志为(?i)
3. re.LOCAL(re.L) 由当前语言决定\w \W \b \B和大小写敏感匹配。不推荐使用。内联标记为(?L)
4. re.MULTILINE(re.M) 多行，设置后^ \$也匹配行，内联标记为(?m)
5. re.DOTALL(re.S) 让点号匹配任何字符，包括换行符，内联标记为(?s)
6. re.VERBOSE(re.X) 允许你编写更具可读性更友好的正则表达式，内联标记为(?x)


### 函数

> re.search(pattern,string,flags=0)  

扫描整个字符串-string找到匹配样式-pattern的第一个位置,其中可以设置flags常量，并返回一个相应的匹配对象(并不是一个字符串)，如果没有匹配，就返回None

> re.match(pattern,string,flags=0)

从字符串-string匹配一个正则表达式-pattern,匹配则返回一个相应的匹配对象。，否则返回None。re.match只匹配字符串的开始(即使定义了flags=r.M也不匹配行首，只匹配字符串开始)。re.search在整个字符串范围内匹配(当然如果在pattern中定义了^也是要匹配字符串开始的)

> re.fullmatch(pattern,string,flags=0)

如果整个字符串匹配到正则表达式，则返回一个相应的匹配对象，否则返回None

> re.findall(pattern,string,flags=0)

对string返回一个不重复的pattern的匹配列表。string从左到右进行扫描，匹配按照找到的顺序返回。如果没有找到匹配的返回空列表。

> re.finditer(pattern,string,flags=0)

与findall相同，不过返回的是一个迭代器iterator。

> re.sub(pattern,repl,string,count=0,flags=0)

替换字符串中的匹配项。其返回一个将string中匹配pattern的字符串替换为repl(repl可以是字符串或返回字符串的函数)，count默认为0表示匹配到的全部换掉，也可以指定整数。如果没有匹配的字符串则不加任何改变返回string。

#### 匹配对象

注意search() match()等如果匹配不到会返回None，所以在使用匹配对象中的方法属性时需要判断。

> Match.group([group1,...])

返回一个或多个匹配的子组，如果只有一个参数结果就是一个字符串。如果有多个参数结果就是一个元组。如果不加参数返回的就是group(0)就是全局分组匹配整个正则表达式。如果正则表达式使用了(?\<name>)语法，groupN参数也可能是命名组的名字。

> Match.groups()

返回一个元组，包含所有匹配的子组。

> Match.groupdict()

返回一个字典，包含了所有的命名子组。key就是组名，value是匹配的结果

> Match.start([group]) Match.end([group])

返回匹配到的子串的首位位于string字符串中的什么位置

```
>>> email = "tony@tiremove_thisger.net"
>>> m = re.search("remove_this", email)
>>> email[:m.start()] + email[m.end():]
'tony@tiger.net'
```
> Match.re

返回产生这个实例的正则对象

> Match.string
 
返回传递到match()和search()的字符串。
 
## re函数示例与分组语法

```
In [2]: string = "abababab aabaabaab abbabbabb" 

In [9]: re.findall(r"\b(ab)+\b",string)                                                   
Out[9]: ['ab']
# 如果正常解释这个正则表达式 "\b(ab)+\b" 匹配 \b 单词开头 (ab)+ 单词中包括1个以上的ab 匹配单词结束\b
# 正常应该是可以匹配 abababab 单词的，但是实际上匹配的是ab  
# 这是因为在python中()表示分组，即"\b(ab)+\b"匹配到的abababab字符串中(ab)代表的字符串那就是ab本身了
# 如果不想使用分组这个概念可以使用(?:)表示不捕获分组
In [10]: re.findall(r"\b(?:ab)+\b",string)
Out[10]: ['abababab']

#-------------------------------------------------------------------------------------
# 一个真实案例
In [11]: html = '<div><a href="https://support.google.com/chrome/?p=ui_hotword_search" target="_blank">更多</a><p>dfsl</p></div>'

# 如果要匹配a标签中的文字
In [36]: a = re.search(r"<a.*>(.*)</a>",html)
# 返回的结果是一个匹配对象，通过group来获取匹配的结果，()表示分组，其只有一个分组所以group中为1.
In [37]: a.group(1)                                          
Out[37]: '更多'
# 默认有个0表示全局分组，即整个正则表达式匹配的结果
In [38]: a.group(0)                                                           
Out[38]: '<a href="https://support.google.com/chrome/?p=ui_hotword_search" target="_blank">更多</a>'
# 如果我们想要得到a标签中的 href参数 和target参数 以及标签内容
In [42]: aa = re.search(r"<a.*f=\"(.*)\".*t=\"(.*)\">(.*)</a>",html)  
In [45]: aa.group(1)                                                   
Out[45]: 'https://support.google.com/chrome/?p=ui_hotword_search'

In [46]: aa.group(2)                                             
Out[46]: '_blank'

In [47]: aa.group(3)                                                              
Out[47]: '更多'

# 可以使用groups()来获取整个列表
In [49]: aa.groups()                                            
Out[49]: ('https://support.google.com/chrome/?p=ui_hotword_search', '_blank', '更多')

#---------------------------------------------------------------------------------

# 命名分组
# ()可以用于分组其默认使用1,2..这样的数字来给分组编号
# 也可以通过(?P<name>正则表达式) 来为分组命名
# 还是上面的例子
In [50]: aaa = re.search(r"<a.*f=\"(?P<href>.*)\".*t=\"(?P<target>.*)\">(?P<message>.*)</a>",html)
# 此时可以通过命名来引用，当然使用1也可以
In [54]: aaa.group("href")
Out[54]: 'https://support.google.com/chrome/?p=ui_hotword_search'
# 匹配对象有一个groupdit()函数，用于返回命名和值
In [55]: aaa.groupdict()                                          
Out[55]: 
{'href': 'https://support.google.com/chrome/?p=ui_hotword_search',
 'target': '_blank',
 'message': '更多'}
# 后向引用
#正则表达式中，放在圆括号中表示一个组，然后你可以对整个组使用一些正则操作，例如重复操作符
#并且当用()定义了一个正则表达式后，正则引擎会把被匹配的组按照顺序编号存入缓存
# 这样我们想在后面对已经匹配过的内容进行引用时，就可以使用\数字来引用
# 如果定义了(?P<name>)的方式定义了组名，则可以使用(?P=name)进行引用
In [78]:  re.search(r'(?P<name>go)\s+(?P=name)\s+(?P=name)', 'go go go').group('name')
Out[78]: 'go'
# 通过默认分组编号进行后向引用
In [81]: re.search(r'(go)\s+\1\s+\1', 'go go go').group()
Out[81]: 'go go go'



#---------------------------------------------------------------------------------

# re模块中的search match函数都有一个flags参数用来一些设定
In [72]: s = "LINUX is very good"
# 默认区分大小写
In [73]: re.findall(r"linux",s)                                               
Out[73]: []
# 可以通过指定re.I来忽略大小写
In [74]: re.findall(r"linux",s,re.I)                                                     
Out[74]: ['LINUX']
# 可以使用(?i)这样的内联标志代替flags参数，(?iLmsux)来任意指定其中的一个或多个，而且位置可以随意安放都会对全部整条正则式有效，不过不写在规则首部会警告。
In [76]: re.findall(r"(?i)linux",s)
Out[76]: ['LINUX']

#------------------------------------------------------------------------------

# 前向肯定断言 (?=pattern)
# 后向肯定断言 (?<=pattern)
In [83]: s1='''char *a="hello world"; char b='c'; /* this is comment */ int c=1; /* t 
    ...: his is multiline comment */'''
# 需要注意的时，如果在匹配中需要同时使用这两个断言，必须后向肯定在前，前向肯定在后
# 下面是获取C语言中的注释内容
# (?<=/*)这个是后向肯定断言，表示/*之后 (?=*/)这个为前向肯定断言，表示*/之前。这两合并起来就是一个区间了，所以后向肯定放到前向肯定之前
In [84]: re.findall( r'(?<=/\*).+?(?=\*/)' , s1 ,re.M|re.S)
Out[84]: [' this is comment ', ' t\nhis is multiline comment ']

# 前向否定断言 (?!pattern)
# 后向否定断言 (?<!pattern>)
# 提取不是.txt结尾的文件
In [85]: f1 = "aaa.txt"                                                                                                                                  
In [86]: re.findall(r'.*\..*$(?<!txt$)',f1)                                                                                                              
Out[86]: []
# 提取不以数字开头的文件
In [87]: re.findall(r'^(?!\d+).*','1txt.txt') 
Out[87]: []
# 提取不以数字开头不以py结尾的文件
In [88]: re.findall(r'^(?!\d+).+?\..*$(?<!py$)','test.py')
Out[88]: []

```

### 总结

|    元字符     |                                             含义                                             |
| ------------- | -------------------------------------------------------------------------------------------- |
| (...)         | 分组，匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取 |
| (?aiLmsux)    | 正则表达式标记模式，可以所以组合                                                             |
| (?:...)       | 正则括号的非捕获版本，匹配括号内的任何正则表达式，不进行分组                                 |
| (?P<name>...) | 命名组合，默认组合使用1,2..这样的数字命名                                                    |
| (?P=name)     | 反向引用一个命名组合                                                                         |
| \number       | 与上面相同，不过使用\1 \2这样的来引用一个命名组合                                            |
| (?=pattern)   | 前向肯定断言                                                                                 |
| (?<=pattern)  | 后向肯定断言                                                                                 |
| (?!pattern)   | 前向否定断言                                                                                 |
| (?<!pattern>) | 后向否定断言                                                                                 |