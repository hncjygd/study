## Linux文件权限与属性

Linux是多用户操作系统，而多用户并不仅仅是可以建立多个用户和群组就行了，还要有一套其他逻辑来管理不同用户的文件。这就是Linux的权限控制。而实际上Linux多用户权限控制的本质就是让不同的用户能够访问的文件不同罢了。由于root可以访问任何文件，所以也就拥有了至高无上的权利。那规定一个文件具体可以有谁来控制以及如何设置这种控制就是这篇文章需要说明的问题。

## 本篇文章介绍的内容

1. 目录和文件相关的命令
2. 目录和文件的权限
3. 权限管理的相关命令
4. inode相关知识

## 目录和文件相关命令

既然我们要学习Liunx文件权限管理，那么一些操作目录与文件的命令就是必须要学习的。

### cd 切换目录

> cd [相对路径/绝对路径]    #changeDirectory

一些需要记忆的特殊符号作为某些特定路径的别名：

- ~ 代表当前登录用户的家目录
- \- 代表用户上次所在的目录
- . 代表当前目录
- .. 代表上级目录

### pwd 打印当前工作目录

> pwd   # PrintWorkingDirectory

如果你不知道当前所在的目录位置，可以使用该命令。

### ls 列出目录下的文件及目录

> ls [选项] [路径]  #list  如果不加路径默认使用当前路径

其中主要使用到的选项包括：

- -a 列出全部文件，包括隐藏文件(以.开头的)
- -l 使用长格式列出文件和目录信息
- -h 使用人类易读的方式显示文件和目录的大小
- -i 显示文件的inode节点信息

这个命令可以说是linux用到最多的命令，通常我们使用 ls -al 来列出目录下文件的详细信息。

### mkdir 创建目录

> mkdir [-mp] 目录名    #make Directory

其选项解释：

- -m 用于手动配置所创建的目录的权限，而不是使用默认权限 mkdir -m 711 test
- -p 递归创建所有目录 mkdir test1/test2

### rmdir 删除空目录

> rmdir [-p] 目录名 #remove Directory

其选项解释：

    - -p 递归删除空目录

这个命令并不常用，通常我们删除目录使用 rm -rf 命令。但是当你只是想删除空目录的时候可以使用mkdir来确保非空目录不被删除。

### cp 复制文件和目录

> cp [选项] 源文件 目标文件     #copy

其常用选项介绍：

- -d 如果源文件为软链接，则复制出来的目标文件也为软链接
- -p 复制后目标文件保留源文件的属性(包括UID GID 权限 时间)
- -r 递归复制，用于复制目录
- -a 相当于 -dpr 的集合
- -i 如果目标存在则会询问是否覆盖
- -l 把目标文件建立为源文件的硬链接文件，而不是复制源文件
- -s 把目标文件建立为源文件的软链接文件，而不是复制源文件

需要注意的问题：
1. 源文件可以有多个，这种情况下目标文件必须是目录才可以 
2. 复制可以是文件，也可以是目录，要复制目录需要加 -r 或则 -a 选项

### rm 删除文件或目录

> rm [选项] 文件/目录

其常用选项包括：

- -f 强制删除，系统不会询问而是直接删除
- -i 与-f相反，在删除前，系统提示是否删除，是默认选项
- -r 递归删除，用于删除目录

需要注意的问题：

1. rm是一个破坏性命令，其会永久删除文件和目录  (感受到 rm -rf / 的恐惧了吗^-^)
2. 删除成功后系统不会给出提示，这是Linux的一个重要思想，没有提示就意味着成成功

### mv 移动文件或改名

> mv [选项] 源文件 目标文件

其常用选项介绍：

- -f 强制覆盖，即使目标文件已经存在，不询问直接覆盖
- -i 与上面相反，如果目标文件存在，询问是否覆盖
- -n 如果目标文件已经存在，不覆盖也不询问
- -v 显示文件或目录的移动过程
- -u 若目标文件已经存在，但两者比较，源文件更新，则会对目标文件进行升级

需要注意的问题：

1. mv命令可以直接移动目录，而不需要-r这样的递归选项
2. mv命令如果目标文件与源文件在同一个文件夹中时就是改名

## 文件属性和权限

Linux中用权限和属性来规范系统进程与文件和目录之间的交互。我们可以通过 ls -al 命令来查看一个目录下的所有文件和其他目录的权限与属性：

```
[hncjygd@hncjygd-pc etc]$ ls -al
total 1604
drwxr-xr-x 101 root root  12288 11月 24 07:23 .
drwxr-xr-x  17 root root   4096 11月 18 05:15 ..
drwxr-xr-x   3 root root   4096 11月 17 07:13 acpi
-rw-r--r--   1 root root     44 11月 17 06:34 adjtime
drwxr-xr-x   3 root root   4096  9月 11 22:05 alsa
-rw-r--r--   1 root root    541 11月  1 04:37 anacrontab
drwxr-xr-x   2 root root   4096  9月 11 22:06 apparmor
drwxr-xr-x   7 root root   4096 11月 17 07:14 apparmor.d
-rw-r--r--   1 root root    769  9月 26 03:04 appstream.conf
lrwxrwxrwx   1 root root     15 10月 22 05:08 arch-release -> manjaro-release
```

他们的格式是一样的，我们单独拿出一行来分析这个格式：

> drwxr-xr-x   3 root root   4096 11月 17 07:13 acpi

他们一共被分为7个部分依次格式为：

> [文件类型和权限] [链接数] [拥有者] [所属用户组] [文件大小] [最后修改时间] [文件名]

其中最重要的是第一个参数，文件类型和权限，该参数分为四个部分:

>d rwx r-x r-x 对应 [文件类型] [所有者权限] [所数组权限] [其他人权限]

第一个字符描述文件类型其可能的取值如下：
- d 代表目录
- \- 代表文件
- l 代表一个软链接
- b 代表块设备 如：硬盘等
- c 代表字符设备 如：键盘、鼠标等
- s 代表套接字文件
- p 代表命名管道文件

后面的由rwx组成的分别代表所有者、所属组、其他人的权限：
- r 代表可读
- w 代表可写
- x 代表可运行
- \- 代表不具有某一个权限

对于文件的作用：

|  rwx权限   |                              对文件的作用                               |
| ---------- | ----------------------------------------------------------------------- |
| r-读权限   | 表示可读取文件中的内容，即可对文件执行cat more less head tail等命令     |
| w-写权限   | 表示可以编辑文件中的内容，即可执行vim echo等文件数据修改命令            |
| x-执行权限 | 表示该文件可以运行，在linux中文件是否可运行由该权限控制并不受后缀名控制 |  

对于目录的作用：

| rwx权限    | 对目录的作用                                                                             |
|---|---|
| r-读权限   | 表示具有读取目录结构列表的权限,即可执行ls                                                |
| w-写权限   | 可以在目录中建立新的文件或目录，删除已经存在的目录和文件(无论文件或目录的权限如何)等操作 |
| x-执行权限 | 代表用户可以进入该目录，即执行cd命令，查看其中文件的inode信息                                                     |

### 文件权限和属性修改

#### chgrp 修改文件和目录的所属组

> chgrp [-R] 所数组 文件名/目录名  
> -R 表示更改连同目录中所有文件的所属组信息  

更改目录的所属组，就是更改上面文件详细列表的第四个参数。

#### chown 修改文件和目录的所有者或所属组

> chown [-R] 所有者[:所属组] 文件或目录
> -R 表示更改连同目录中的所有文件也更改  

chown可以同时更改所有者和所数组，其中使用分号隔开，也可单独更改。其更改的是上面文件详细列表中的第三、第四个参数。

#### chmod 修改文件或目录的权限

根据上面知道文件/目录的权限由九个字符组成，并且三个一对分别代表所有者、所属组、其他人。这其中有两种表示方法:

1. rwx 这样的符号表示
2. r=4 w=2 x=1 这样的数字表示，比如 rwx=7 rw-=6 r-x=5 r--=4 -wx=3 -w-=2 --x=1

使用数字修改权限：

> chmod [-R] 权限值 文件名/目录名  
> -R 用于目录，表示连同目录中的文件一同修改  
> 权限值就是使用数字形式表示例如： chmod 755 example 就是将example文件权限更改为 rwxr-xr-x

使用字符修改文件权限：  
既然文本的基本权限是三个用户身份(所有者 所属组 其他人)搭配三种权限(rwx)。所以可以使用 u代表所有者， g代表所属组，o代表其他人，a代表全部这三个身份，三个权限依然用rwx代表，以此为依据来更改权限。  

> chmod u=rwx,go=rx example  
> 等同于 chmod 755 example  

从上面的实例可以看到，数字修改是最方便的形式，忘记字符吧。  

#### umask 临时修改新建文件或目录的默认权限

在新建文件或文件夹的时候，系统会给予默认的权限。这个权限具体是什么可以使用umask来查询，对于manjaro来说为 0022 。  
也许会疑惑为什么是0022这样的表示难道默认的权限是 ----w--w-，不是这样而是刚好相反，系统并不直接使用umask这个值，而是使用以下公式:  

> 文件/目录的最大默认权限 - umask权限  
> 对于文件默认最大权限为666即rw-rw-rw-,因为x权限是文件的最高权限有可能会损坏系统，所以必须手动赋予  
> 对于目录默认最大权限就是777即rwxrwxrwx  
> 所以在manjaro中 文件的默认权限就是rw-rw-rw-减去----w--w-即rw-r--r--  
> 目录的默认权限是rwxrwxrwx减去----w--w-即rwxr-xr-x  

umask在不加参数的时候可以查询系统的默认权限，也可通过添加数字来改变默认权限：

> umask 033  
> umask权限为 ----wx-wx  
> 此时文件默认权限为：rw-rw-rw-减去----wx-wx即rw-r--r--  
> 此时目录默认权限为：rwxrwxrwx减去----wx-wx即rwxr--r--  

需要注意的是，这种修改仅仅临时有效，在退出终端的时候就不再有效了，如果想要永久生效，需要更改配置文件/etc/profile。这个配置文件是一个sh脚本文件，当用户第一次登录时，该文件被执行，并从/etc/profile.d/目录的配置文件中搜集shell的设置。其中定义了环境信息。针对有每个用户都有效。其中有一条信息就是设置umask=0022的，如果你想要让umask永久生效就更改这个配置文件。注意修改完成后依然不会生效需要重新启动或则source一下让修改生效(因为系统启动会运行该命令，如果想要生效就必须重新运行一下)

### 链接数属性以及引出的inode

经过上面的讲解我们已经对ls -al列出来的权限和属性的意义和修改方法基本讲解的差不多了。但是还有一个属性还没有在任何地方提到，那就是链接数。要想搞清楚这个属性就必须要搞清楚Linux保存文件的方法。  
Linux使用的文件系统是一种基于inode的文件系统，inode被翻译成中文就是索引节点。

#### 具体什么是索引节点(inode)呢？

要想理解inode，就必须知道文件是如何在硬盘中存储的。文件存储在硬盘上，硬盘的最小存储单位是扇区，每个扇区存储512字节。由于扇区数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作，即块是操作系统中最小的逻辑存储单元。这样可以使操作系统忽略底层物理存储结构的设计。磁盘块是操作系统自己“杜撰”的，是一个虚拟的概念。其大小由操作系统决定，通常一个块 = 单个扇区大小 * 2的n次方，其中n是可修改的，最常见的一个块是4KB.  
文件数据既然都存储在块中，那么必然的我们还需要找到一个地方来存储文件的元信息，比如文件的创建者、创建日期、大小、文件所在块的地址等信息。而这些存储文件元信息的区域就是inode，中文译名索引节点。每一个文件都有对应的inode。  
没一个inode中保存的具体信息包括：  

- 文件的大小
- 文件所有者的UID
- 文件所属组的GID
- 文件的权限
- 文件的时间戳
    - AccessTime(atime) 访问时间指文件上一次被打开的时间
    - ModifyTime(mtime) 数据修改时间指文件内容上一次变动的时间
    - ChangeTIme(ctime) 状态修改时间指文件状态变化的时间，实际上就是**inode上一次变动的时间**(所以权限修改、mv cp操作、文件修改等都会改变这个时间)
- 链接数 即多少文件指向这个inode
- 文件数据的block的位置

我们可以使用 stat 命令来查询某一个文件的索引信息：  

> stat /etc/passwd  

```
  File: /etc/passwd
  Size: 1821            Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d      Inode: 6688353     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2019-11-24 20:53:24.322120589 +0800
Modify: 2019-11-24 20:53:24.322120589 +0800
Change: 2019-11-24 20:53:24.322120589 +0800
 Birth: 2019-11-24 20:53:24.322120589 +0800
```  
需要注意的是文件名并没有保存在inode上，实际上系统是通过inode值来找到文件的，我们可以通过ls -i命令来得到文件的inode值。系统内部找到文件的过程是首先找到这个文件名对应的inode号码，通过inode号码获取inode信息，最后根据inode信息找到文件所在的block读取数据。  

inode本身也是存储在硬盘上的，相应的也会消耗因盘空间。操作系统进行硬盘格式化的时候会自动将硬盘分成两个区域：数据区域和inodes区域。每个inode节点是有大小的一般是256字节。inode节点的总数在格式化就给定，一般是每1KB就设置一个inode。  

可以使用df -i来查看每个硬盘分区的inode总数和已经使用的数量：  
```
Filesystem     Inodes IUsed IFree IUse% Mounted on
dev              1.5M   499  1.5M    1% /dev
run              1.5M   811  1.5M    1% /run
/dev/sda1        8.6M  310K  8.3M    4% /
tmpfs            1.5M   183  1.5M    1% /dev/shm
tmpfs            1.5M    18  1.5M    1% /sys/fs/cgroup
tmpfs            1.5M    57  1.5M    1% /tmp
/dev/sda3        5.5M   94K  5.4M    2% /home
/dev/sda4           0     0     0     - /boot/efi
tmpfs            1.5M    44  1.5M    1% /run/user/1000
tmpfs            1.5M    16  1.5M    1% /run/user/1001
```
例如上面的/dev/sda1有8.6M个inode，使用了310K个还有8.3M个。  
由于每个文件必须有一个inode，并且inodes是在格式化后就分配好的，所以会出现硬盘还未存满，就无法在硬盘上创建新文件了(通常由于小文件太多以及软链接太多引起的)

#### 目录inode与权限的关系

在linux中一切皆文件，目录当然也不例外，其也是一种文件。打开目录实际上就是打开了目录文件。目录文件的中保存了一系列的目录项列表。我们执行ls -l命令就是根据文件每个目录项找到他们的inode号找到inode节点来读取其中的信息并罗列出来。  
此时在来看目录和文件的权限：  
读权限(r) - 用来读取文件存储块中的信息，对于目录就是目录中保存的每个目录项(即通过 ls 列出来的信息)  
写权限(w) - 可以删除、修改块中的信息  
执行权限(x) - 可以读取inode节点内的信息  
假设我们只给予/etc/目录的rw权限而不给x权限，虽然可以通过 ls /etc/来列出文件的内容，但是我们在使用ls -l是详细信息并不能显示:
```
d????????? ? ? ? ?             ? acpi
-????????? ? ? ? ?             ? adjtime
d????????? ? ? ? ?             ? alsa
-????????? ? ? ? ?             ? anacrontab
d????????? ? ? ? ?             ? apparmor
d????????? ? ? ? ?             ? apparmor.d
-????????? ? ? ? ?             ? appstream.conf
l????????? ? ? ? ?             ? arch-release
-????????? ? ? ? ?             ? asound.conf
d????????? ? ? ? ?             ? audisp
d????????? ? ? ? ?             ? audit
d????????? ? ? ? ?             ? avahi
-????????? ? ? ? ?             ? bash.bash_logout
-????????? ? ? ? ?             ? bash.bashrc
-????????? ? ? ? ?             ? bindresvport.blacklist
d????????? ? ? ? ?             ? binfmt.d

```
这是因为没有x权限无法查看文件的inode信息也就无法显示文件的详细信息了。

#### 硬链接/软链接与inode的关系

##### 硬链接

一般情况下，文件名和inode号是一一对应的，每个inode号对应一个文件名。但是linux也允许多个文件指向同一个inode号码，这就意味着，可以用不同的文件名访问同样的内容，对于文件内容进行修改，会影响到所有文件名，但是删除一个文件名不影响另一个文件名的访问。这种情况就被称为硬链接。而在inode信息中的link属性以及ls -l中显示的第二个属性就是表明这个inode的链接数也就是一个文件的硬链接数量或者叫文件的别名数量。当然因为硬链接指向同一个inode信息所以其有一下特点：

1. 无论是修改源文件，还是修改硬链接文件，另一个文件中的数据都会发生改变
2. 无论是删除源文件，还是删除硬链接文件，只要还有一个文件存在这个文件就可以被访问
3. 硬链接不会建立inode信息
4. 硬链接不能跨分区建立，应为在不同的文件系统中，inode号是重新计算的
5. 硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的文件也需要建立硬链接，这太过复杂了

关于硬链接还有一个知识点，创建目录时会默认生成两个目录项.和..，他们分别代表当前目录以及父目录，他们就是通过硬链接完成的，所以任何一个目录的硬链接总数总是等于2加上他们的子目录总数(因为每个子目录中都会创建一个..指向自己的父目录)。  

##### 软链接

除了硬链接还有一种软链接，他们的inode号虽然不一样，例如A和B，其中A的内容是B的路径，读取文件A时，系统会自动将访问路径指向文件B。因此无论打开哪一个文件，最终读取的都是文件B中的内容。这个时候就称为文件A是文件B的软链接。这意味着A依赖于文件B而存在，如果删除了文件B，打开文件A会报错这个时候称文件A为死链，当然如果你重新在A记录的路径下创建了同名的文件，文件A会重新指向这个新建的文件。软链接有自己本身有自己的inode域。因此创建软链接并不会增加inode信息中的连接数。而软链接除了在删除源文件时导致软链接失效外，其可跨分区创建、目录软链接等优点在实际使用中被广泛应用。  

#### 创建链接

> ln [-s] 源文件 目标文件  
> -s: 创建软链接，如果不加-s即为创建硬链接

## 总结

万物皆文件，目录也是文件。而inode元信息就是保存了文件的(inode号，大小，块地址、权限、连接数、GID、UID、时间)等数据。而文件名并不保存在inode中(他们保存在父目录的块数据中)。文件的块数据保存了文件本身的内容，而目录的块数据保存了其下所有文件的文件名以及对应的文件inode号。   
对于r权限就是读取文件块中的内容，对于w权限就是更改文件块的内容，对于x就是读取inode中的信息。  

我们以目录为例：  

1. 如果只给予r权限，那么我们只能读取该目录文件块的内容即可以得到文件名以及文件的inode，所以一个目录被赋予r我们可以使用ls列出其中的文件(读取了块)  
2. 如果给予rw权限，则可以编辑目录文件块，对于目录来说就是删除/新建/移动目录内的文件(目录文件块中保存的就是这些条目信息)，而实际上文件的文件名就是保存在目录文件块中的  
3. 如果给予x权限，则表示可以对inode进行操作，我们可以删除该目录，查询目录下文件的详细信息等操作  

对于硬链接和软链接：

1. 硬链接是一个文件的别名，这个别名是保存在硬链接所在的目录文件块中的，硬链接本身是没有块域的。这个别名指向了一个已经存在的inode号的，而他指向的文件是由这个inode号中指向的地址决定的
2. 软链接有自己的块域，这也就意味着他有自己的inode信息，软链接的块域中保存了指向的文件的路径信息，所以知道路径信息下没有指向的文件的时候就成为死链了  

对于文件操作的一些命令解释：

1. cp复制命令：就是找到一个空闲的inode号，把增加文件的元数据写入到一个数据块中并将其元信息写入到这个inode号指向的inode表中。同时在所在目录的目录文件块中添加一条项目记录了该文件的文件名以及对应的inode号。
2. mv移动命令：系统首先在目标目录的目录文件块中添加一条项目记录了目标文件名以及源文件的inode号，然后删除旧目录下文件块中关于源文件的信息。同时更新这个文件的inode元信息即可。所以mv命令并没有改变indoe号，其在实体硬盘中存储的位置还是同样的，只不过是更改了两个目录的块域而已。(当然这是正对位于同一个分区下的文件而言的)
3. rm删除命令：系统首先将这个文件的链接数减去1,如果此时inode的链接数变为了0那么就释放这个inode号并且释放其对应的磁盘空间，删除文件所在目录中关于该文件的信息。而如果链接数没有为0,删除操作仅仅删除文件所在目录中关于该文件的信息而已。

总结：我们对于文件的几乎所有操作实际上就是对文件的inode元信息以及文件块的操作，如果你深刻的理解了这两个部分存储的内容以及用处就可以理解为什么这个操作会产生这样的结果。