# 修改文本操作

其实对于vim的操作基本上就分为两大块，一块是插入文本，一块就是修改文本。本节将介绍修改文本的一系列操作。

## 删除文本

实际上删除操作主要是使用d操作符加上一些动作来完成的，这是最主要的操作方式，但是vim中还是定义了一些常用的删除方式：  

- x 删除光标下的字符，与dl相同
- X 删除光标前的字符，与dh相同
- dd 删除一行
- D 删除光标所在位置的字符到行尾，与d$相同
- J 连接两行，删除缩进，插入不多于两个的空格(实际上就是删除了换行符以及行首的缩进)
- gJ 连接两行，不删除缩进，实际上就是只删除行末的换行符

## 删除并插入文本

实际上就是使用c操作符加上一些动作来完成，还可以看成使用d操作符删除后通过i等进入插入模式，其中vim定义了一下常用的:  

- R 进入替换模式，不断替换光标下字符
- cc 删除行并进入插入模式，等同于ddi
- C 等同于Di
- s 删除当前字符并开始插入等同于dl或xi

## 简单修改文本

其中有些命令绑定了一些内置的函数，有时候会有意想不到的效果，例如大小写替换等：  

- r 替换光标下字符
- ~ 切换光标下字符的大小写
- ~{motion} 默认情况下~后不能接动作，但是可以:set tildeop 来改变这个行为，此时单独使用~不再改变光标下字符的大小写
- g~{motion} 等同于tildeop下的~，可以切换动作跨越的文本的大小写  
- g~\~ 切换当前行的大小写
- gU{motion} 切换为大写
- gUU 将本行切换为大写
- gu{motion} 切换为小写
- guu{motion} 将本行切换为小写

## 复杂修改

过滤命令，就是将文本中的一些字符通常是几行作为标准输入，做出某些修改，并将结果放到标准的输出的程序。  

- !{motion}{filter} 将motion跨越的行用外部程序过滤，例如!4lsort 按字母顺序给行排序

替换，即将一个字符串替换为其他字符串：  

- :[range]s[ubstitute]/{pattern}/{string}/[flangs] 其意义就是将range代表的行中的pattern指带的字符串由string替换掉flags是标志位定义了一些替换规则  
- range作用范围可以是当前行用.表示，可以是全文用%表示，也可以是visual下的选区等 例如 :%s/vaule/value 将全文的vaule字符串替换为value
- flags标志位，i表示大小写不敏感，c表示替换前确认

## 复制并粘贴文本

复制命令就是使用y操作符加上一些动作完成的，而粘贴使用p来完成，需要注意的是实际上d c命令删除的文本并没有被真正删除，而是放置到寄存器中了，我们都可以使用p命令来粘贴出来。

- y{motion} 抽出motion跨越的文本
- yy 抽出当前行的文本
- p 放置文本在光标之后
- P 放置文本在光标之前
- gp 与p相同，不过光标放置到新文本之后
- gP 与P相同，不过光标放置到新文本之后

## vim中的寄存器

vim中将y c d中得到文本实际上是放到了寄存器里面了，而p命令实际上是从寄存器中得到字符并放到文件的buffer中了。实际上我们可以在ycd前加上寄存器的名字来指定将结果放置到相应的寄存器内，例如："ayy 表示复制本行到a寄存器内，而取出该寄存器的内容就是"ap 了。接下来这里来详细介绍下vim中的寄存器。  

1. "" 无名寄存器
2. "0~"9 十个编号寄存器
3. "- 行内删除寄存器
4. "a~"z("A~"Z) 26个命名寄存器
5. ": ". "% 三个只读寄存器
6. "# 轮换缓冲寄存器
7. "= 表达式寄存器
8. "* "+ "~ 选择和托放寄存器
9. "_ 黑洞寄存器
10. “/ 最近搜索模式寄存器

### 无名寄存器

用d c s x y等删除复制命令所得到的文本都被用来填充该寄存器了，不管是否用别的专门寄存器。就好像无名寄存器是指向最近使用的那个寄存器的指针一样，使用大写寄存器进行添加时，无名寄存器包含和命名寄存器相同的文本，其中"_ 黑洞寄存器是个例外，"_dd命令并不会把删除的文本放到任何寄存器里。不指定寄存器的p命令使用无名寄存器的内容，当然也可以显示制定 p"" 来粘贴。写入无名寄存器的内容实际上是写入到了寄存器"0上。  

### 编号寄存器

vim把抽出和删除命令的文本都保存在这些寄存器里了。  
编号寄存器0包含了最近抽出的文本，除非该命令使用["x]指定了别的寄存器。  
编号寄存器1包含了最近删除或修改的文本，除非命令指定了其他寄存器或者该文本小于一行(小于一行的数据被保存在行内删除寄存器内)。每一次新的删除和修改，vim把前一次的寄存器1中的内容复制到寄存器2,2到3,以此类推。而最后寄存器9的内容就丢失了。

### 行内删除寄存器

该寄存器保存删除不到一行内容的命令的文本，除非该命令指定了其他寄存器。  

### 命名寄存器

Vim只有在你指定的时候才使用这些寄存器。指定为小写字母时替换原来的内容，制定为大写字母时附加到原来的内容。

### 只读寄存器

这些寄存器中不能写入内容，只能使用p命令来放置他们，其中：

- ". 寄存器包含了最近插入的文本
- "% 保存了当前文件名
- ": 保存了最近执行过的命令

### 轮换文件寄存器

包含当前窗口轮换文件的名字。影响ctrl+^命令的工作方式。该寄存器是可写的，但是并不建议自行设置，通常提供给插件来更改的。  

> :let @#=buffer_name 使用buffer来更改该寄存器的内容

### 表达寄存器

其实并没有这么一个寄存器可以存储文本，这是用来在使用寄存器的命令中使用表达式的一个方式。  

### 选择和托放寄存器

这是用在GUI版本中的

### 黑洞寄存器

当写入到这个寄存器时，什么都没有发生，这可以用来删除文本，而不影响任何正常的寄存器。从该寄存器读取是什么也不返回。通常情况下我们将长久需要保存的文本放置到命名寄存器中，而那些一定不用的使用黑洞寄存器彻底删除，对于编号寄存器相当提供了历史供我们使用。

### 最近搜索寄存器

含有最近一次搜索的模式，他被n和hlsearch使用，实际上n/N就是不断带用这个寄存器的过程，而hlseearch就是将该寄存器中匹配的文本高亮。你不能将抽出或删除的命令内容放到该寄存器中。但是我们可以使用let命令来在该寄存器中写入。

> :let @/="value" 如果甚至了hlsearch则value字符将被高亮
> :let @/="" 相当与删除了该寄存器的内容，这时候高亮有也取消了

我们有的时候在打开一个文本的时候，会发现该文本中部分字符被高亮了，就是其中保存了内容，你可以通过删除这个寄存器或者关闭hlsearch选项来实现取消高亮。

### 寄存器相关命令

- :registers 显示所有编号和命名寄存器的内容。

## 撤销与重做

- u 撤销一次更改
- ctrl+r 重做被撤销的更改

## 重复

对于大范围并且大量重复操作的时候就需要使用打重复操作，这可以极大的提高工作的效率。

### 单次重复

- . 点号，单次重复，会重复你的输入以及更改操作，注意不能重复命令行命令。
- @: 重复上一次命令行命令，实际上就是调用了只读寄存器":

### 宏操作

宏操作首先需要录制宏，q{0-9a-zA-Z} 来开启录制宏，实际上就是将宏保存到了相应的寄存器内了。 然后执行一系列命令，h k l等光标移动，dyp等更改操作，i插入文本等命令都可以，这些都会被保存在寄存器中，最后通过q来退出宏录制。然后我们就可以使用a{0-9a-zA-Z}来使用这个宏命令了。  

举例说明,我们对以下输出处理一下，我们只需要文件名，而不需要其他信息，并且文件名使用双引号包括：
```
drwxr-xr-x   7 root root   4096  9月 11 22:05 ppp
-rw-r--r--   1 root root    207 12月  5 18:39 printcap
-rw-r--r--   1 root root    759 10月 22 05:08 profile
-rw-r--r--   1 root root   3145 11月  1 02:01 protocols
drwxr-xr-x   2 root root   4096 11月 17 07:14 pulse
drwxr-xr-x   2 root root   4096  5月  7  2019 rc_keymaps
-rw-r--r--   1 root root   1634 10月 21 14:14 rpc
drwxr-xr-x   3 root root   4096  9月 11 22:05 samba
drwxr-xr-x   5 root root   4096  9月 11 22:06 X11
drwxr-xr-x   9 root root   4096 12月  2 07:15 xdg
drwxr-xr-x   2 root root   4096  9月 11 22:07 xml
-rw-r--r--   1 root root   1285  7月 25  2017 yaourtrc
drwxr-xr-x   2 root root   4096  9月 11 20:57 zsh
```
首先我们想想如果要操作一行怎么进行，首先$行尾，b到文件名首字母处，d0删除到行首，i进入插入模式"添加引号，esc推出插入模式e到单词尾部a进入插入模式添加双引号就可以了。现在我们来录制宏。  
我把宏录制进了a寄存器中可以使用"ap来看看内容:$bd0i""�kbea""�kb,可以看到就是你写入的命令(^[是esc键,还记得ctrl+[等同于esc吗). 然后我们就可以进入的下一行通过@a来执行这个宏命令了。  
此时你会想到这么多要一个个应用@a也很麻烦啊，此时有两种解决途经: 

1. 在宏编制的时候使用j将光标移动到下一行，@a后光标就在下一个行了，此时可以使用n@a来重复执行@a命令了  
2. 通过shift+v 进入行Visual模式，选择所有的行在命令行中执行 :normal @a (注意其前面会有前导符号不用管他，vim自动给添加的)，该命令的意思是在命令行中执行normal的命令，并且应用到全部选择的行


```
"ppp"
"printcap"
"profile"
"protocols"
"pulse"
"lock"
"rc_keymaps"
"cfg"
"rpc"
"samba"
"X11"
"xdg"
"xml"
"yaourtrc"
"zsh"
```
